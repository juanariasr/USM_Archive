#lang scheme

;el problema de usar recursion es que si o si se van a revisar nodos innecesarios aun cuando sea encontrado el nodo deseado

(define (izquierda nodo)
  ;(printf "izquierda nodo: ")(display (car(cdr nodo)))(newline)
  (if (null? nodo)
      '()
      (cadr nodo)
      )
  )
(define (derecha nodo)
  ;(printf "derecha nodo: ")(display (car(cddr nodo)))(newline)
  (if (null? nodo)
      '()
      (caddr nodo)
      )
  )
(define (visitar nodo)
  ;(printf "nodo: ")(display nodo)(newline)
  (if (null? nodo)
      '()
      (if (and (null? (cadr nodo)) (null? (caddr nodo)))
          (car nodo)
       (car nodo)
       )
      )
  )
(define (visit nodo)
  ;(printf "nodo: ")(display nodo)(newline)
  (if (null? nodo)
      '()
      (if (or (memv 4 (cadr arbol)) (memv 4 (caddr arbol)))
          #t
       (car nodo)
       )
      )
  )

(define (preorden arbol)
  (if (null? arbol)
      '()
      (append
       (list(visit arbol))
       (preorden (izquierda arbol))
       (preorden (derecha arbol))
       )
      )
  )

(define (pre-izq arbol)
  (let pre([arbol (cadr arbol)])
    (if (null? arbol)
        '()
        (append
         (list (visitar arbol))
         (pre(izquierda arbol))
         (pre(derecha arbol))   
         )
        )
    )
  )
(define (pre-der arbol)
  (let pre([arbol (caddr arbol)])
    (if (null? arbol)
        '()
        (append
         (list(visitar arbol))
         (pre(izquierda arbol))
         (pre(derecha arbol))
         )
        )
    )
  )

(define arbol '(5 (3 (2 () ()) (4 () ())) (8 (6 () ()) ())))

(define nodo1 '(3 (2 () ()) (4 () ())))
(define nodo2 '(8 (6 () ()) ()))
(define nodo3 '(2 () ()))
(define nodo4 '(4 () ()))
(define nodo5 '(6 () ()))

(cadr arbol) ;hijo izquierdo
(caadr arbol) ;valor hijo izquierdo
(caddr arbol) ;hijo derecho
(caaddr arbol) ;valor hijo derecho





;(and (null? (cadr arbol)) (null? (caddr arbol))) ;hijo
;(or (memv 4 (cadr arbol)) (memv 4 (caddr arbol))) ;si en los hijos esta la wea
(append (list 3)
        (let haruhi ([a 2])
          (if (= 3 a)
            (list 4)
            (haruhi (+ 1 a)) 
            )
          )
        (let nagatoro([b 3])
          (if ( = 4 b)
              (list 69)
              (nagatoro (+ 1 b))
              )
          )
        )


